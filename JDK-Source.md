# JDK源码
## 1、 HashMap
    1、HashMap的数据结构(jdk1.7 , jdk1.8的区别)
         底层数据结构不一样，jdk7采用的bucket数组 + 链表；jdk8采用的是bucket数组 +链表加 红黑树
         jdk7中 如果链表过长会怎样？
         如果链表过长表示hahs冲突的次数过多，jdk7中当发现hashmap的数据容量达到阈值，则会进行扩容，重新生成一个新的数组，并且重新计算hash值生成索引，存放数据，利用空间换时间的原理
         jdk7中hashmap扩容会引发哪些问题？
         1、会引发死锁问题也就是说循环链表 ，在多个线程同时进行扩容操作时，就会产生循环链表的问题
         2、还会存在数据丢失问题 
         jdk1.8 是等链表整个 while 循环结束后，才给数组赋值，此时使用局部变量 loHead 和 hiHead 来保存链表的值，因为是局部变量，所以多线程的情况下，肯定是没有问题的。 

         一个极端的场景是红黑树最终成环，
         在多线程环境下还是推荐使用concurrentHashmap 保证并发安全
    2、HashMap的实现原理
    3、HashMap的扩容为什么是2^n-1
    4、HashMap是线程安全的吗？
    5、HashMap和HashTable是什么关系

    6、HashCode 为什么使用31作为乘数 
       基于实验表明，使用31作为成乘数能够有效的减少哈希碰撞的次数，以及生成的hash值 能够散列分布 
       31在jvm内部会被优化成位运算 
       31 * i = （i << 5） - i 能提升性能因为直接操作的是二进制码

    7、为什么进行扰动计算
       说白了扰动计算 让高位与低位进行混合运算 ，让数据元素更加均匀的散列，增加了随机性，最终还是为了减少哈希碰撞的概率  

    8、 jdk7 和 jdk8 hashmap扩容之后 如何生成新的索引的
        hashmap的容量达到阈值之后就需要进行扩容，jdk7 需要重新计算hash来确定新的索引位置
        jdk8 内部做了优化，将hash值与旧的容量进行&操作，如果值等于零 则新的索引位置=旧的索引位置
        如果等于1 ，则新的索引位置 = 旧的index + 1